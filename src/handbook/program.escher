
BuildProgramPage {
        wf *io.WriteFile
        wf:Content = *ProgramPage
        wf:Name = "program.html"
        : = wf:Ready
}

ProgramFigures {
	f *Fork
	f:ScanPrint = fig1:
	f:Telescope = fig2:
	f:Expanded = fig3:
	f:Flattened = fig4:
	f: = :

	fig1 *FigurePngSvgRight
	fig1:Image = "scanprint"
	fig1:Width = "400px"
	fig1:Caption = `*`
	fig1:Right = `
	<pre class="escher">
	main {
		scanln os.Scanln
		println os.Println
		scanln:Read = println:Write
	}
	</pre>
	`

	fig2 *FigurePngSvg
	fig2:Image = "telescope"
	fig2:Width = "600px"
	fig2:Caption = `This is a <a href="syntax.html">symbolic representation</a> 
	of two circuit designs, named <code>App</code> and <code>Database</code>.
	The illustration omits valve names.`

	fig3 *FigurePngSvg
	fig3:Image = "expanded"
	fig3:Width = "500px"
	fig3:Caption = `The inversion of colors—from white-on-black in the enclosing circuit, to
	black-on-white in the substituted circuits—is a visual symbolism indicating that 
	the substitutions are separate data-structures from the enclosing one. Specifically,
	the visual links that cross circuits are not explicitly represented in the data structure.
	This can be accomplished by flattening (see below).`

	fig4 *FigurePngSvg
	fig4:Image = "flattened"
	fig4:Width = "500px"
	fig4:Caption = `After flattening circuits recursively, all gates end up in the same giant circuit.
	In order to preserve the circuit invariant that no two gates have the same name,
	gates are automatically renamed to reflect the root-to-leaf path to them in the unflattened circuit.`
}

ProgramPage {
	h *Html
	h: = :
	h:Title = "Programs and materialization"
	h:Body = t:

	t *text.QuickForm
	t:Data = *ProgramFigures
	t:Form = `

<h1>Programs and materialization</h1>

<p>
Materialization is the process of creating and executing a system of
interconnected reflexes, wherein the system is specified by a circuit
called a program.

<p>Materialization takes as input an index (of circuit programs and
other reflex materializers) and a circuit program to materialize.
The result of materialization is the creation and execution of the
system of reflexes described by the circuit program, as well as a
residual value.

<h2>Circuit programming</h2>

<p>A program circuit describes a system of interconnected reflexes.

<p>Each circuit gate corresponds to a reflex. The gate value 
describes the type of reflex that is to be materialized. While the
gate name is merely an identifier, unique to the program circuit,
used mainly to enable the specification of the reflex-to-reflex links.
The relation between gate values and materialized reflexes is explained later.

<p>In a valid program circuit, a gate whose name is the empty
string must not be defined. The empty-string gate is reserved for
the <em>super gate</em>, which (detailed later) designates an “enclosing” circuit.

<p>The circuit program's links connect pairs of reflex-valve endpoints.
Links are allowed either between two gates defined within the circuit,
or between a defined gate and the super gate.

<p>Links connected to the super gate are endpoints whose eventual connection
to a reflex is defered to the enclosing circuit.

<p>Circuit programs that have no links to the super gate are called <em>closed</em>
circuits, as they describe complete materializable systems on their own.

<p>On the other hand, circuit programs that have links to the super gate
can only be materialized as reflexes within higher-level enclosing circuits.

<h3>Gate value interpretation</h3>

<p>Circuit programs recognize the following types of gate values:
<ul>
<li>Integer, float, complex, string, or a non-directive circuit, or</li>
<li><a href="meaning.html#directives">Directive circuit</a>
</ul>

<h4>Noun reflexes</h4>

<p>Gate values in the first group (integer, float, complex, string or a non-directive circuit) 
will result in the materialization of a “noun” reflex, whose noun value is the
gate value.

<p>A noun reflex is a generic built-in reflex type which, after materialization,
emits its corresponding gate value to each one of its connected valves.
If no valves are connected, the noun reflex leaves the gate value as its 
residue. Otherwise, it leaves no residue.

<h4>Expanding directives</h4>

<p>When the gate value is a <a href="meaning.html#directives">directive</a>,
materialization proceeds as follows:

<ul>
<li>First, the runtime looks up the “target” value, which resides in the index
at the address specified in the directive.</li>
<li>Second,
<ul>
<li>If the directive verb is <code>@</code>, the gate is materialized as a noun gate
emitting the target value.</li>
<li>If the directive verb is <code>*</code>, the target value is substituted as the gate value,
and the materialization process described in this section is repeated now with the target
value as the gate value.
</ul>
</li>
</ul>

<h3>Circuit residue</h4>

<p>As pointed out in the <a href="reflex.html">section on reflexes</a>, every reflex
can leave a residue value as a result of being materialized, or the Go value <code>nil</code>
which indicates leaving no residue.

<p>Circuit programs are no different than reflexes (in fact they describe higher-order reflexes themselves)
in that they leave a residue value as well.

<p>The residue of materializing a circuit program is the same circuit,
wherein each gate value is replaced by the residue of materializing that gate.
Gate corresponding to reflexes that leave no residue are not present
in the residue circuit.

<p>If no gates leave any residue, the circuit program itself leaves no residue.

<h2>Example with an illustration</h2>

<p>Consider, for instance, the following index:

<pre>
{
	Database {
		cache Cache
		left Shard
		right Shard
		link Link
		cache:Web = :Web
		left:Cache = cache:Left
		right:Cache = cache:Right
		left:Backup = link:Left
		right:Backup = link:Right
		link: = :Backup
	}
	App {
		web Web
		left Database
		right Database
		backup Backup
		left:Web = web:Left
		right:Web = web:Right
		left:Backup = backup:Left
		right:Backup = backup:Right
	}
	Web …
	Cache …
	Shard …
	Link …
}
</pre>

<p>Here <code>App</code> and <code>Database</code> are program circuits and their symbolic
representation is shown below.
Whereas assume that <code>Web</code>, <code>Cache</code>, <code>Shard</code> and <code>Link</code>
(whose definition is not given in this listing) are reflex materializers.

{{.Gate.Telescope}}

{{.Gate.Expanded}}

{{.Gate.Flattened}}


<h2>Three ways to invoke materialization</h2>

<p>…

`
}
